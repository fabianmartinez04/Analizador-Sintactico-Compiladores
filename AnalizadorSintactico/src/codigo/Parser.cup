package codigo;
import  java_cup.runtime.Symbol;

/*Parser code*/
parser code
{:
    public void syntax_error(Symbol s) {
        String lexeme = s.value.toString();
        int row = s.right;
        int column = s.left;
        System.out.println("ERROR-1: " + lexeme + " row: " + row + " column: " + column);
        /*Guardar el error en una estructura de datos*/
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {        
        String lexeme = s.value.toString();
        int row = s.right;
        int column = s.left;
        System.out.println("ERROR-2: " + lexeme + " row: " + row + " column: " + column);
    }
:}


/* Grammatical action code*/
action code 
{:
:}

/*Synmbol Terminal and No-terminal*/
/*TERMINALS*/
terminal String INCR,DECR,EQUAL,ADD,SUB,MUL,DIV,MOD,OPEN_BRACKET,CLOSE_BRACKET,ADD_EQUAL,SUB_EQUAL,MUL_EQUAL,DIV_EQUAL, OPEN_KEY, CLOSE_KEY;
terminal String EQUAL_TO,GREATER_EQUAL,LESS,LESS_EQUAL,GREATER,NOT_EQUAL,LOGICAL_OR,LOGICAL_AND,LOGICAL_NOT;
terminal String LITERAL_STR,FLOAT_NUMBER,OCTAL_NUMBER,NUMBER,HEXADECIMAL_NUMBER,FLOAT_POINT_NUMBER,BINARY_NUMBER;
terminal String I_BREAK,I_CASE,I_CHAR,I_CONST,I_CONTINUE,I_DEFAULT,I_DO,I_ELSE,I_FOR,I_IF,I_INT,I_LONG,I_RETURN,I_SHORT,I_SWITCH,I_VOID,I_WHILE;
terminal String SEMICOLON, COMMA, IDENTIFIER;

/*NON TERMINALS*/
non terminal String program, exp_list, exp, data_type, value, str;

start with program;

program     ::= exp_list:el                              {: RESULT= el; :}
;
exp_list    ::= exp: e exp_list:el                       {: RESULT= el; :}
                | exp:e                                  {: RESULT= e; :}
;
exp         ::= data_type:t IDENTIFIER:id SEMICOLON      {: RESULT= t + " " + id + " ;"; :}
                | data_type:t IDENTIFIER:id EQUAL value:v SEMICOLON      {: RESULT= t + " " + id + " = " + v + " ;"; :}
                | I_SWITCH:s OPEN_BRACKET:ob NUMBER:n CLOSE_BRACKET:cb OPEN_KEY:ok NUMBER:n1 CLOSE_KEY:ck   {: RESULT = s + ob + n + cb + ok + n1 + ck ; :}
                
;
data_type   ::= I_CHAR:e                                 {: RESULT= e; :}
                | I_INT:e                                {: RESULT= e; :}
                | I_LONG:e                               {: RESULT= e; :}
                | I_SHORT:e                              {: RESULT= e; :}
;
value       ::= NUMBER:e                                 {: RESULT= e; :}
                | LITERAL_STR:e                          {: RESULT= e; :}
;






/*Grammatical rules*/
/*
<expr> --> number
<expr> --> ( expr )
<expr> --> expr + expr
<expr> --> expr - expr
<expr> --> expr * expr
<expr> --> expr / expr

<compound stmt> --> { <stmt list> }
<stmt list> --> <stmt> <stmt list> | epsilon
<stmt> --> <compound stmt>
<stmt> --> id : <stmt>
<stmt> --> if ( <expr> ) <stmt>
<stmt> --> if ( <expr> ) <stmt> else <stmt>
<stmt> --> while ( <expr> ) <stmt>
<stmt> --> do <stmt> while ( <expr> ) ;
<stmt> --> for ( <stmt> <expr> ; <expr> ) <stmt>
<stmt> --> switch (number) { <mult case stmt> }
<mult case stmt> --> <case stmt> <mult case stmt> | epsilon
<case stmt> --> case number : <stmt> | default: <stmt>
<stmt> --> break ; | continue ; | ;
<stmt> --> return <expr> ; | goto case number ;
*/