package codigo;
import  java_cup.runtime.*;
import java.util.LinkedList;

/*Parser code*/
parser code
{:
    public LinkedList<ErrorMsg> errorList = new LinkedList<ErrorMsg>();
 
    public void syntax_error(Symbol s) 
    {
        String lexeme = s.value.toString();
        int row =  s.right + 1;
        int column = s.left + 1;
        System.out.println("Sintax error at: " + lexeme + " row: " + row + " column: " + column);
        ErrorMsg error =  new ErrorMsg(lexeme, "Syntax error", row, column);
        errorList.add(error);
    }

    public void unrecovered_syntax_error(Symbol s)
    {        
        String lexeme = s.value.toString();
        int row = s.right + 1;
        int column = s.left + 1;
        System.out.println("Unrecovered Sintax error: " + lexeme + " row: " + row + " column: " + column);
        ErrorMsg error =  new ErrorMsg(lexeme, "Syntax error", row, column);
        errorList.add(error);
    }
:}


/* Grammatical action code*/
action code 
{:
:}

/*Synmbol Terminal and No-terminal*/
/*TERMINALS*/
terminal String INCR, DECR, EQUAL, ADD, SUB, MUL, DIV, MOD;
terminal String OPEN_BRACKET, CLOSE_BRACKET, ADD_EQUAL, SUB_EQUAL, MUL_EQUAL, DIV_EQUAL, OPEN_KEY, CLOSE_KEY;
terminal String EQUAL_TO, GREATER_EQUAL, LESS, LESS_EQUAL, GREATER, NOT_EQUAL, LOGICAL_OR, LOGICAL_AND, LOGICAL_NOT;
terminal String LITERAL_STR, FLOAT_NUMBER, FLOAT_POINT_NUMBER;
terminal String OCTAL_NUMBER, NUMBER, HEXADECIMAL_NUMBER, BINARY_NUMBER;
terminal String I_BREAK, I_CASE, I_CHAR, I_CONST, I_CONTINUE, I_DEFAULT, I_DO, I_ELSE, I_FOR, I_IF, I_INT, I_LONG;
terminal String I_RETURN, I_SHORT, I_SWITCH, I_VOID, I_WHILE;
terminal String SEMICOLON, COMMA, IDENTIFIER,COLON;

/* NON TERMINALS */
non terminal String program, decl_list, global_decl, const_decl, funct_decl, var_type, var_decl, functin_init;
non terminal String literal, declaration, var_func_decl_list, stmts, var_func_decl;
non terminal String structs, struct_decl, struct_type, condition_for, condition, var, comparator, change_var,if,else;
non terminal String switch_sent,mult_case_stmt, case_stmt, case_fin, return,if_sent,if_inst,else_inst, asign_equal;
non terminal String equals, incr_decr, math_expr, value, expr_uni, expr_math, expr;
start with program;

program ::= decl_list:dl
;
decl_list ::= declaration:d decl_list:dl
    | declaration:d | asign_equal:ae
;
declaration ::= global_decl:gl
    | const_decl:cl 
    | funct_decl:fl 
    | error SEMICOLON
    | error OPEN_KEY
    | error CLOSE_KEY
    | error OPEN_BRACKET
    | error CLOSE_BRACKET
    | error IDENTIFIER
;
global_decl ::= var_func_decl COMMA var_decl:vd SEMICOLON
    | var_func_decl EQUAL literal:l COMMA var_decl:vd SEMICOLON
    | var_func_decl SEMICOLON
    | var_func_decl EQUAL literal:l SEMICOLON
;
var_type ::=  I_SHORT:i
    | I_LONG:i
    | I_CHAR:i
    | I_INT:i
    | I_CHAR:i MUL:m
;
var_decl   ::= IDENTIFIER:i EQUAL literal:l
    | IDENTIFIER:i
    | IDENTIFIER:i EQUAL literal:l COMMA var_decl:vd
    | IDENTIFIER:i COMMA var_decl:vd
;
literal	::= NUMBER:n
    | LITERAL_STR:s
    | OCTAL_NUMBER:n
    | HEXADECIMAL_NUMBER:n
    | BINARY_NUMBER:n
;
const_decl  ::= I_CONST var_type:vt var_decl:vd SEMICOLON
;
funct_decl ::= functin_init:fi OPEN_BRACKET:ob var_func_decl_list:vfdl CLOSE_BRACKET:cb OPEN_KEY:ok stmts:s CLOSE_KEY:ck
    | functin_init:fi OPEN_BRACKET:ob CLOSE_BRACKET:cb OPEN_KEY:ok stmts:s CLOSE_KEY:ck
    | functin_init:fi OPEN_BRACKET:ob CLOSE_BRACKET:cb OPEN_KEY:ok CLOSE_KEY:ck
    | functin_init:fi OPEN_BRACKET:ob var_func_decl_list:vfdl CLOSE_BRACKET:cb OPEN_KEY:ok CLOSE_KEY:ck
;
functin_init   ::= var_func_decl:cfd
    | I_VOID:i IDENTIFIER:id
;
var_func_decl_list   ::= var_func_decl:vfd COMMA var_func_decl_list:vfdl
    | var_func_decl:vfd
;
var_func_decl ::= var_type:vt IDENTIFIER:i
;

stmts ::= const_decl stmts:s
        | const_decl
        | global_decl:gl stmts:s
        | global_decl:gl
        | structs:st stmts:sm
        | structs:st 
        | asign_equal:ae SEMICOLON:sc stmts:sm
        | asign_equal:ae SEMICOLON:sc
        | incr_decr SEMICOLON:sc stmts:sm
        | incr_decr
        | expr_math SEMICOLON:sc stmts:sm
        | expr_math
;



structs ::= struct_decl OPEN_KEY:ok stmts:s CLOSE_KEY:ck
           |switch_sent:ss 
           |if_sent:is
;            
struct_decl ::= struct_type:st OPEN_BRACKET:ob condition:c CLOSE_BRACKET:cb
            | struct_type:st OPEN_BRACKET:ob condition_for:cf CLOSE_BRACKET:cb 
;
struct_type ::= I_FOR:f
               |I_WHILE:w
;

if_sent ::= if_inst:is else_inst:es
        |if_inst:is
;

if_inst ::= I_IF:i OPEN_BRACKET:ob condition:c CLOSE_BRACKET:cb OPEN_KEY:ok stmts:s CLOSE_KEY:ck 
;

else_inst ::= I_ELSE:i OPEN_KEY:ok stmts:s CLOSE_KEY:ck 
;

switch_sent ::= I_SWITCH:s OPEN_BRACKET:o var:v CLOSE_BRACKET:c OPEN_KEY:ok mult_case_stmt:mcs CLOSE_KEY:ck
;

mult_case_stmt ::= case_stmt:cs mult_case_stmt:mcs | case_stmt:cs                                           
; 
case_stmt ::= I_CASE:c NUMBER:n COLON stmts:s case_fin:cf 
            | I_CASE:c NUMBER:n COLON stmts:s return:r
            | I_CASE:c NUMBER:n COLON stmts:s case_fin:cf return:r
            | I_CASE:c NUMBER:n COLON stmts:s
            | I_DEFAULT:d COLON:c stmts:s case_fin:cf 
            | I_DEFAULT:d COLON:c stmts:s return:r
            | I_DEFAULT:d COLON:c stmts:s case_fin:cf return:r
            | I_DEFAULT:d COLON:c stmts:s
;
case_fin ::= I_BREAK:b SEMICOLON | I_CONTINUE:c SEMICOLON                                                     
;
return ::= I_RETURN:r NUMBER:n SEMICOLON:s                                                                    
;

change_var ::= INCR:i
            |DECR:d
;
condition ::=  var:v comparator:c var:v1 
;
condition_for ::= var_type:vt var_decl:vd SEMICOLON:sc condition:c SEMICOLON:sc1 incr_decr
;
incr_decr ::= IDENTIFIER:i change_var:cv
;
comparator ::= EQUAL_TO:et 
             |GREATER_EQUAL:ge
             |LESS:l
             |LESS_EQUAL:le
             |GREATER:gr
             |NOT_EQUAL:ne
;
var ::= NUMBER:n
    | IDENTIFIER:i
;
asign_equal ::= IDENTIFIER:i equals:e var
;

equals ::= ADD_EQUAL 
    | SUB_EQUAL 
    | MUL_EQUAL 
    | DIV_EQUAL
;
/*
math_expr ::= math_expr expr_math_part 
    | expr_math_part;
expr_math_part ::= expr_math;
expr_math ::= expr_math ADD expr_math 
    | expr_math SUB expr_math 
    | expr_math MUL expr_math 
    | expr_math DIV expr_math  
    | expr_math MOD expr_math
//    | MINUS expr %prec UMINUS
    | OPEN_BRACKET expr_math CLOSE_BRACKET
    | value
;
*/
expr_math ::= value expr_uni 
    | expr 
;
expr_uni ::= ADD:a value:n
    | SUB:s value:n
    | MUL:m value:n
    | DIV:d value:n
    | MOD:d value:n 
;
expr ::= value:n ADD:a value:n1
;
expr ::= value:n SUB:s value:n1
;
expr ::= value:n MUL:m value:n1
;
expr ::= value:n DIV:d value:n1
;
expr ::= value:n MOD:d value:n1
;
expr ::= OPEN_BRACKET:o expr:e CLOSE_BRACKET:c
;
expr ::= value:n
;
value ::= NUMBER:n
    | IDENTIFIER:i
    | OCTAL_NUMBER:n
    | HEXADECIMAL_NUMBER:n
    | BINARY_NUMBER:n
;

