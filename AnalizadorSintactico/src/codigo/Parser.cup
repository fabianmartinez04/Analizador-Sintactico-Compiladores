package codigo;
import  java_cup.runtime.*;
import java.util.LinkedList;

/*Parser code*/
parser code
{:
    public LinkedList<ErrorMsg> errorList = new LinkedList<ErrorMsg>();
 
    public void syntax_error(Symbol s) 
    {
        String lexeme = s.value.toString();
        int row =  s.right + 1;
        int column = s.left + 1;
        System.out.println("Sintax error at: " + lexeme + " row: " + row + " column: " + column);
        ErrorMsg error =  new ErrorMsg(lexeme, "Syntax error", row, column);
        errorList.add(error);
    }

    public void unrecovered_syntax_error(Symbol s)
    {        
        String lexeme = s.value.toString();
        int row = s.right + 1;
        int column = s.left + 1;
        System.out.println("Unrecovered Sintax error: " + lexeme + " row: " + row + " column: " + column);
        ErrorMsg error =  new ErrorMsg(lexeme, "Syntax error", row, column);
        errorList.add(error);
    }
:}


/* Grammatical action code*/
action code 
{:
:}

/*Synmbol Terminal and No-terminal*/
/*TERMINALS*/
terminal String INCR, DECR, EQUAL, ADD, SUB, MUL, DIV, MOD;
terminal String OPEN_BRACKET, CLOSE_BRACKET, ADD_EQUAL, SUB_EQUAL, MUL_EQUAL, DIV_EQUAL, OPEN_KEY, CLOSE_KEY;
terminal String EQUAL_TO, GREATER_EQUAL, LESS, LESS_EQUAL, GREATER, NOT_EQUAL, LOGICAL_OR, LOGICAL_AND, LOGICAL_NOT;
terminal String LITERAL_STR, FLOAT_NUMBER, FLOAT_POINT_NUMBER,LITERAL_CHAR;
terminal String OCTAL_NUMBER, NUMBER, HEXADECIMAL_NUMBER, BINARY_NUMBER;
terminal String I_BREAK, I_CASE, I_CHAR, I_CONST, I_CONTINUE, I_DEFAULT, I_DO, I_ELSE, I_FOR, I_IF, I_INT, I_LONG;
terminal String I_RETURN, I_SHORT, I_SWITCH, I_VOID, I_WHILE;
terminal String SEMICOLON, COMMA, IDENTIFIER,COLON;

/* NON TERMINALS */
non terminal String program, decl_list, global_decl, const_decl, funct_decl, var_type, var_decl, functin_init;
non terminal String literal, declaration, var_func_decl_list, stmts, var_func_decl;
non terminal String structs, struct_decl, struct_type, condition_for, condition, var, comparator, change_var,if,else;
non terminal String switch_sent,mult_case_stmt, case_stmt, case_fin, return,if_sent,if_inst,else_inst, asign_equal;
non terminal String equals, incr_decr, math_expr, expr_uni, expr_math, expr,symbol,case_default,cases_switch,stmts_switch,assigment_type;


start with program;



program ::= decl_list:dl
;
decl_list ::= declaration:d decl_list:dl
    | declaration:d | asign_equal:ae
;
declaration ::= global_decl:gl
    | const_decl:cl 
    | funct_decl:fl 
    | error SEMICOLON
    | error OPEN_KEY
    | error CLOSE_KEY
    | error OPEN_BRACKET
    | error CLOSE_BRACKET
    | error IDENTIFIER
   
;
global_decl ::= var_func_decl COMMA var_decl:vd SEMICOLON
    | var_func_decl EQUAL assigment_type:at COMMA var_decl:vd SEMICOLON
    | var_func_decl SEMICOLON
    | var_func_decl EQUAL assigment_type:at SEMICOLON
    | I_CHAR:i IDENTIFIER:i1 EQUAL LITERAL_CHAR SEMICOLON
    

;
var_type ::=  I_SHORT:i
    | I_LONG:i
    | I_INT:i
    | I_CHAR:i MUL:m

;


var_decl   ::= IDENTIFIER:i EQUAL assigment_type:at
    | IDENTIFIER:i
    | IDENTIFIER:i EQUAL assigment_type:at COMMA var_decl:vd
    | IDENTIFIER:i COMMA var_decl:vd
;

assigment_type ::= LITERAL_STR:ls
                | expr_math:em
                
;

const_decl  ::= I_CONST var_type:vt var_decl:vd SEMICOLON
          
;
funct_decl ::= functin_init:fi OPEN_BRACKET:ob var_func_decl_list:vfdl CLOSE_BRACKET:cb OPEN_KEY:ok stmts:s CLOSE_KEY:ck
    | functin_init:fi OPEN_BRACKET:ob CLOSE_BRACKET:cb OPEN_KEY:ok stmts:s CLOSE_KEY:ck
    | functin_init:fi OPEN_BRACKET:ob CLOSE_BRACKET:cb OPEN_KEY:ok CLOSE_KEY:ck
    | functin_init:fi OPEN_BRACKET:ob var_func_decl_list:vfdl CLOSE_BRACKET:cb OPEN_KEY:ok CLOSE_KEY:ck

;
functin_init   ::= var_func_decl:cfd
    | I_VOID:i IDENTIFIER:id
;
var_func_decl_list   ::= var_func_decl:vfd COMMA var_func_decl_list:vfdl
    | var_func_decl:vfd
;
var_func_decl ::= var_type:vt IDENTIFIER:i

                
                
;

stmts ::= const_decl stmts:s
        | const_decl
        | global_decl:gl stmts:s
        | global_decl:gl
        | structs:st stmts:sm
        | structs:st 
        | asign_equal:ae SEMICOLON:sc stmts:sm
        | asign_equal:ae SEMICOLON:sc
        | incr_decr SEMICOLON:sc stmts:sm
        | incr_decr
        | expr_math SEMICOLON:sc stmts:sm
        | expr_math
;
stmts_switch ::= structs:st stmts_switch:sw
                | structs:st 
                | asign_equal:ae SEMICOLON:sc stmts_switch:sw 
                | asign_equal:ae SEMICOLON:sc
                | IDENTIFIER:i EQUAL assigment_type:at SEMICOLON stmts_switch:sw
                | IDENTIFIER:i EQUAL assigment_type:at SEMICOLON
                | incr_decr SEMICOLON:sc stmts_switch:sw  
                | incr_decr
                | expr_math SEMICOLON:sc stmts_switch:sw  
                | expr_math
;


structs ::= struct_decl OPEN_KEY:ok stmts:s CLOSE_KEY:ck
           |switch_sent:ss 
           |if_sent:is
;            
struct_decl ::= struct_type:st OPEN_BRACKET:ob condition:c CLOSE_BRACKET:cb
            | struct_type:st OPEN_BRACKET:ob condition_for:cf CLOSE_BRACKET:cb 
;
struct_type ::= I_FOR:f
               |I_WHILE:w
;

if_sent ::= if_inst:is else_inst:es
        |if_inst:is
;

if_inst ::= I_IF:i OPEN_BRACKET:ob condition:c CLOSE_BRACKET:cb OPEN_KEY:ok stmts:s CLOSE_KEY:ck 
;

else_inst ::= I_ELSE:i OPEN_KEY:ok stmts:s CLOSE_KEY:ck 
;

switch_sent ::= I_SWITCH:s OPEN_BRACKET:o var:v CLOSE_BRACKET:c OPEN_KEY:ok cases_switch:cs CLOSE_KEY:ck
;


cases_switch ::= mult_case_stmt:mc case_default:cd
                |mult_case_stmt:mc
;
mult_case_stmt ::= case_stmt:cs mult_case_stmt:mcs 
                   | case_stmt:cs 
 
; 
case_default ::= I_DEFAULT:d COLON:c stmts_switch:s case_fin:cf 
            | I_DEFAULT:d COLON:c stmts_switch:s return:r
            | I_DEFAULT:d COLON:c stmts_switch:s case_fin:cf return:r
            | I_DEFAULT:d COLON:c stmts_switch:s
            
;
case_stmt ::= I_CASE:c NUMBER:n COLON stmts_switch:s case_fin:cf 
            | I_CASE:c NUMBER:n COLON stmts_switch:s return:r
            | I_CASE:c NUMBER:n COLON stmts_switch:s case_fin:cf return:r
            | I_CASE:c NUMBER:n COLON stmts_switch:s 
            | I_CASE:c NUMBER:n COLON case_fin:cf 
            | I_CASE:c NUMBER:n COLON return:r
            | I_CASE:c NUMBER:n COLON case_fin:cf return:r
            | I_CASE:c NUMBER:n COLON 
;
case_fin ::= I_BREAK:b SEMICOLON | I_CONTINUE:c SEMICOLON                                                     
;
return ::= I_RETURN:r var:v SEMICOLON:s  
        | I_RETURN:r SEMICOLON:s 
;

change_var ::= INCR:i
            |DECR:d
;
condition ::=  var:v comparator:c var:v1 
;
condition_for ::= var_type:vt var_decl:vd SEMICOLON:sc condition:c SEMICOLON:sc1 incr_decr
;
incr_decr ::= IDENTIFIER:i change_var:cv
;
comparator ::= EQUAL_TO:et 
             |GREATER_EQUAL:ge
             |LESS:l
             |LESS_EQUAL:le
             |GREATER:gr
             |NOT_EQUAL:ne
;
var ::= NUMBER:n
    | IDENTIFIER:i
;
asign_equal ::= IDENTIFIER:i equals:e var
;

equals ::= ADD_EQUAL 
    | SUB_EQUAL 
    | MUL_EQUAL 
    | DIV_EQUAL
;
/*
math_expr ::= math_expr expr_math_part 
    | expr_math_part;
expr_math_part ::= expr_math;
expr_math ::= expr_math ADD expr_math 
    | expr_math SUB expr_math 
    | expr_math MUL expr_math 
    | expr_math DIV expr_math  
    | expr_math MOD expr_math
//    | MINUS expr %prec UMINUS
    | OPEN_BRACKET expr_math CLOSE_BRACKET
    | literal
;
*/

//(1+2+5+(2+2*(9-9)))

//((2+2))
expr ::= expr_math:em
      
;

expr_math ::= expr_uni:eu expr_math:em
            | expr_uni:eu 
            | symbol:s OPEN_BRACKET:o expr_math:em CLOSE_BRACKET:c expr_math:em1
            | symbol:s OPEN_BRACKET:o expr_math:em CLOSE_BRACKET:c
            | OPEN_BRACKET:o expr_math:em CLOSE_BRACKET:c expr_math:em1
            | OPEN_BRACKET:o expr_math:em CLOSE_BRACKET:c
            | literal:u expr_uni:eu expr_math:em
            | literal:u expr_uni:eu
            | literal:u
;
expr_uni ::= ADD:a literal:n
    | SUB:s literal:n
    | MUL:m literal:n
    | DIV:d literal:n
    | MOD:d literal:n 
;
symbol ::= ADD:a
        |SUB:s
        |MUL:m
        |DIV:d
        |MOD:d
;

literal ::= NUMBER:n
    | IDENTIFIER:i
    | OCTAL_NUMBER:n
    | HEXADECIMAL_NUMBER:n
    | BINARY_NUMBER:n
;

