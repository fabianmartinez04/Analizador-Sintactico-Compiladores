package codigo;
import  java_cup.runtime.Symbol;

/*Parser code*/
parser code
{:
    public void syntax_error(Symbol s) {
        String lexeme = s.value.toString();
        int row = s.right;
        int column = s.left;
        System.out.println("ERROR-1: " + lexeme + " row: " + row + " column: " + column);
        /*Guardar el error en una estructura de datos*/
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {        
        String lexeme = s.value.toString();
        int row = s.right;
        int column = s.left;
        System.out.println("ERROR-2: " + lexeme + " row: " + row + " column: " + column);
    }
:}


/* Grammatical action code*/
action code 
{:
:}

/*Synmbol Terminal and No-terminal*/
/*TERMINALS*/
terminal String INCR,DECR,EQUAL,ADD,SUB,MUL,DIV,MOD,OPEN_BRACKET,CLOSE_BRACKET,ADD_EQUAL,SUB_EQUAL,MUL_EQUAL,DIV_EQUAL;
terminal String EQUAL_TO,GREATER_EQUAL,LESS,LESS_EQUAL,GREATER,NOT_EQUAL,LOGICAL_OR,LOGICAL_AND,LOGICAL_NOT;
terminal String LITERAL_STR,FLOAT_NUMBER,FLOAT_POINT_NUMBER,BINARY_NUMBER;
terminal Integer OCTAL_NUMBER,NUMBER,HEXADECIMAL_NUMBER,BINARY_NUMBER;
terminal String I_BREAK,I_CASE,I_CHAR,I_CONST,I_CONTINUE,I_DEFAULT,I_DO,I_ELSE,I_FOR,I_IF,I_INT,I_LONG,I_RETURN,I_SHORT,I_SWITCH,I_VOID,I_WHILE;
terminal String SEMICOLON, COMMA, IDENTIFIER;

/*NON TERMINALS*/
non terminal String program;

start with program;

program ::= global_list:gl funct_list:fl
    | const_list:cl funct_list:fl
    | funct_list:fl
;
global_list ::= global:g global_list:gl 
    | global:g
;
global  ::= var_def_list:vdl
;
const_list  ::= const_def:cd const_list:cl
    | const_def:cd
;
const_def   ::= I_CONST var_def:vd
;
funct_list  ::= function function_list:fl
    | function:f
;
function    ::= function_type:ft IDENTIFIER OPEN_BRACKET var_def_function_list:vdfl CLOSE_BRACKET decl_list:dl
;
function_type   ::= I_SHORT
    | I_LONG
    | I_CHAR
    | I_INT
;
var_def_function_list   ::= var_def_function:vdf COMMA var_def_function_list:vdfl
    | var_def_function:vdf /*puede no tener parametros agregar vaci√≥*/
;
var_def_function    ::= var_type:vt IDENTIFER
;
decl_list   :=  OPEN_KEY 




/*::= exp_list:el                              {: RESULT= el; :}
;
exp_list    ::= exp: e exp_list:el                       {: RESULT= el; :}
                | exp:e                                  {: RESULT= e; :}
;
exp         ::= data_type:t IDENTIFIER:id SEMICOLON      {: RESULT= t + " " + id + " ;"; :}
                | data_type:t IDENTIFIER:id EQUAL value:v SEMICOLON      {: RESULT= t + " " + id + " = " + v + " ;"; :}
                
;
data_type   ::= I_CHAR:e                                 {: RESULT= e; :}
                | I_INT:e                                {: RESULT= e; :}
                | I_LONG:e                               {: RESULT= e; :}
                | I_SHORT:e                              {: RESULT= e; :}
;
value       ::= NUMBER:e                                 {: RESULT= e; :}
                | LITERAL_STR:e                          {: RESULT= e; :}
;
*/




/*Grammatical rules*/
/*
<expr> --> number
<expr> --> ( expr )
<expr> --> expr + expr
<expr> --> expr - expr
<expr> --> expr * expr
<expr> --> expr / expr

<compound stmt> --> { <stmt list> }
<stmt list> --> <stmt> <stmt list> | epsilon
<stmt> --> <compound stmt>
<stmt> --> id : <stmt>
<stmt> --> if ( <expr> ) <stmt>
<stmt> --> if ( <expr> ) <stmt> else <stmt>
<stmt> --> while ( <expr> ) <stmt>
<stmt> --> do <stmt> while ( <expr> ) ;
<stmt> --> for ( <stmt> <expr> ; <expr> ) <stmt>
<stmt> --> switch (number) { <mult case stmt> }
<mult case stmt> --> <case stmt> <mult case stmt> | epsilon
<case stmt> --> case number : <stmt> | default: <stmt>
<stmt> --> break ; | continue ; | ;
<stmt> --> return <expr> ; | goto case number ;
*/